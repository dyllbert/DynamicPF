<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pf: paper</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pf
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_paper_paper.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">paper </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
<p> title: 'A Short Introduction to PF: A C++ Library for Particle Filtering' tags:</p><ul>
<li>particle filter</li>
<li>c++ authors:</li>
<li>name: Taylor R. Brown orcid: 0000-0003-4972-6251 affiliation: 1 affiliations:</li>
</ul>
<p>name: Department of Statistics, University of Virginia, PO Box 400135, Charlottesvilla, VA 22904, USA index: 1 date: 14 July 2020 </p><h2>bibliography: paper.bib </h2>
<h1>Summary</h1>
<p>The <code>PF</code> library provides <b>class and function templates</b> that offer fast implementations for a variety of particle filtering algorithms. Each of these algorithms are useful for a wide range of time series models.</p>
<p>In this library, each available particle filtering algorithm is provided as an abstract base class template. Once the data analyst has a specific state-space or hidden Markov model in mind, she will pick which type(s) of particle filtering algorithm(s) to associate with that model by including the appropriate header file. For each model-particle filter pair, she will write a class template for her model that inherits from the particle filter's base class template.</p>
<p>The details of each algorithm are abstracted away, and each algorithm's class template's required functions are pure virtual methods, meaning that the data analyst will not be able to omit any function that is required by the algorithm.</p>
<p>This is by no means the first <code>C++</code> library to be offered that provides particle filter implementations. Other options include <code>LibBi</code> [], <code>Biips</code> [], <code>SMCTC</code> [:2009:JSSOBK:v30i06] and <code>Nimble</code> [:10.1080/10618600.2016.1172487]. The goals of these software packages are different, though&ndash;users of these libraries write their models in a scripting language, and that model file gets parsed into <code>C++</code> code. This library is designed for users that prefer to work in <code>C++</code> directly.</p>
<h1>Statement of Need</h1>
<p>State-space models describe a partially-observed Markov chain&ndash;they possess a hidden/latent variable at each time point, in addition to an observed variable. <code>Filtering" is defined as obtaining the distributions of each unobserved state/code random variable, conditioning on all of the observed information up to that point in time.&lt;/tt&gt;Particle filters" are a class of algorithms that approximate this sequence of distributions with weighted samples (termed particles). Filtering is a useful tool for a variety of applications in a variety of fields, but it should also be mentioned that they can be used for real-time forecasting with only minor modifications, and they are critical component of more advanced parameter estimation algorithms.</code></p>
<p><code>Unfortunately, it takes time and effort to implement different particle filters well, and this is true for two reasons. First, the mathematical notation used to describe them can be complex. The second reason is that, even if they are correctly implemented, they can be quite slow, limiting the number of tasks that they would be feasible for. This library attempts to provide speed and abstraction to mitigate these two difficulties.</code></p>
<p><code>Additionally, this software is designed in an object-oriented manner. This allows for individual particle filters to be used in isolation, and it also facilitates the implementation of more complicated algorithms that update many particle filters through many iterations in a stateful way, possibly in parallel. For this second class of algorithms, there are usually two necessary loops: the <code>outer" loop that loops over time, and the&lt;/tt&gt;inner" loop that iterates over each distinct particle filter. Without an object-oriented design, there would be a third loop, which loops over all particle samples in each particle filter. Some examples of opportunities include particle filters with parallelized resampling schemes [@1453776,1309.2918], particle Markov chain Monte Carlo algorithms [], importance sampling "squared" [], and the particle swarm algorithm [].</code></code></p>
<p><code><code>Finally, this library is "header-only." As a result, building your <code>C++</code> project is as simple as possible. The only required steps are <code>#include</code>-ing relevant headers, and pointing the compiler at the <code>include/pf/</code> directory. This directory stores all necessary code, although there there are unit tests and examples provided as well.</code></code></p>
<p><code><code></p><h1>Example</h1>
<p></code></code></p>
<p><code><code></code></code></p>
<p><code><code>A fully-worked example is provided along with this software available at <a href="https://github.com/tbrown122387/pf">https://github.com/tbrown122387/pf</a>. This example considers modeling a financial time series with a simple stochastic volatility model [] with three parameters: $, $ and $$. For this model, the observable rate of return $y_t$ is normally distributed after conditioning on the contemporaneous state random variable $x_t$. The mean parameter of this normal distribution will remain fixed at $0$. However, the scale of this distribution will vary with the evolving $x_t$. When $x_t$ is relatively high, the returns will have a high conditional variance and be "volatile." When $x_t$ is low, the returns will be much less volatile.</code></code></p>
<p><code><code>The observation equation is {eqnarray} y_t =  e^{x_t/2} z_t {eqnarray} where $z_t </code></code></p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
